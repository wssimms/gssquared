/*
 *   Copyright (c) 2025 Jawaid Bazyar

 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.

 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.

 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <time.h>
/* #include <mach/mach_time.h> */

#include "gs2.hpp"
#include "cpu.hpp"
#include "clock.hpp"

#if 0
// nanosleep isn't real. Combine usleep and the busy wait.
void emulate_clock_cycle_old(cpu_state *cpu) {
    
    /* uint64_t start_time = mach_absolute_time();  // Get the start time */
    uint64_t sleep_time = cpu->cycle_duration_ticks;
    // Optional: Add a small sleep for longer intervals if necessary to reduce CPU usage
    if (sleep_time < 25000) { // disable sleep for now.
        uint64_t current_time = mach_absolute_time();
        while (current_time - cpu->last_tick <= cpu->cycle_duration_ticks) {
            current_time = mach_absolute_time();
        }
    } else {
        struct timespec req = {0, static_cast<long> (cpu->last_tick + cpu->cycle_duration_ticks - mach_absolute_time() ) };
        nanosleep(&req, NULL);
    }
    cpu->last_tick = mach_absolute_time();
}

void emulate_clock_cycle(cpu_state *cpu) {
    
    uint64_t current_time = mach_absolute_time();
    if (cpu->next_tick < current_time) { // clock slip
        cpu->next_tick = current_time + cpu->cycle_duration_ticks;
        cpu->clock_slip++;
    } else {
        uint64_t sleep_time = (cpu->next_tick - current_time);
        if (sleep_time < 25000) { // if we're close, just busy wait
            while ( current_time < cpu->next_tick) {
                current_time = mach_absolute_time();
            }
            cpu->clock_busy++;
        } else {
            struct timespec req = {0, static_cast<long> (sleep_time ) };
            nanosleep(&req, NULL);
            cpu->clock_sleep++;
        }
        cpu->next_tick = cpu->next_tick + cpu->cycle_duration_ticks;
    }
    cpu->last_tick = current_time;
}
#endif

#if 0
void incr_cycles(cpu_state *cpu) {
    cpu->cycles++;
    /* if (cpu->clock_mode != CLOCK_FREE_RUN) { // temp disable this to try different timing approach
        emulate_clock_cycle(cpu);
    } */
}
#endif

#include "platforms.hpp"
#include "display/display.hpp"

/*
 * Here's what's going on in the function mega_ii_cycle()
 *
 *     In the Apple II, the display is generated by the video subsystem.
 * Central to the video subsytem are two counters, the horizontal counter
 * and the vertical counter. The horizontal counter is 7 bits and can be
 * in one of 65 states, with values 0x00, then 0x40-0x7F. Of these 65
 * possible states, values 0x58-0x7F represent the 40 1-Mhz clock periods
 * in which video data is displayed on a scan line. Horizontal blanking and
 * horizontal sync occur during the other 25 states (0x00,0x40-0x57).
 *     The vertical counter is 9 bits and can be in one of 262 states, with
 * values 0xFA-0x1FF. Of these 262 possible states, values 0x100-0x1BF
 * represent the 192 scan lines in which video data is displayed on screen.
 * Vertical blanking and vertical sync occur during the other 70 states
 * (0x1C0-0x1FF,0xFA-0xFF).
 *     The horizontal counter is updated to the next state every 1-Mhz cycle.
 * If it is in states 0x40-0x7F it is incremented. Incrementing the horizontal
 * counter from 0x7F wraps it around to 0x00. If the horizontal counter is in
 * state 0x00, it is updated by being set to 0x40 instead of being incremented.
 *     The vertical counter is updated to the next state every time the
 * horizontal counter wraps around to 0x00. If it is in states 0xFA-0x1FF,
 * it is incremented. If the vertical counter is in state 0x1FF, it is updated
 * by being set to 0xFA instead of being incremented.
 *     The bits of the counters can be labaled as follows:
 * 
 * horizontal counter:        H6 H5 H4 H3 H2 H1 H0
 *   vertical counter:  V5 V4 V3 V2 V1 V0 VC VB VA
 *      most significant ^                       ^ least significant
 * 
 *     During each 1-Mhz cycles, an address is formed as a logical combination
 * of these bits and terms constructed from the values of the soft switches
 * TEXT/GRAPHICS, LORES/HIRES, PAGE1/PAGE2, MIXED/NOTMIXED. The video subsytem
 * reads the byte at this address from RAM and, if the counters are in states
 * that correspond to video display times, use the byte to display video on
 * screen. How this byte affects the video display depends on the current video
 * mode as set by the soft switches listed above. If the counters are in states
 * that correspond to horizontal or vertical blanking times, a byte is still
 * read from the address formed by the video subsystem but it has no effect
 * on the display. However, the byte most recently read by the video subsystem,
 * whether it affects the video display or not, can be obtained by a program
 * by reading an address that does not result in data being driven onto the
 * data bus. That is, by reading an address that does not correspond to any
 * RAM/ROM or peripheral register.
 *     The address read by the video subsystem in each cycle consists of 16
 * bits labeled A15 (most significant) down to A0 (least significant) and is
 * formed as described below:
 * 
 * The least signficant 3 bits are just the least signifcant 3 bits of the
 * horizontal counter:
 * 
 *     A0 = H0, A1 = H1, A2 = H2
 * 
 * The next 4 bits are formed by an arithmetic sum involving bits from the
 * horizontal and vertical counters:
 *
 *       1  1  0  1
 *         H5 H4 H3
 *   +  V4 V3 V4 V3
 *   --------------
 *      A6 A5 A4 A3
 * 
 * The next 3 bits are just bits V0-V2 of the vertical counter (nb: these
 * are NOT the least signficant bits of the vertical counter).
 * 
 *     A7 = V0, A8 = V1, A9 = V2
 * 
 * The remaining bits differ depending on whether hires graphics has been
 * selected or not and whether, if hires graphics has been selected, mixed
 * mode is on or off, and whether, if mixed mode is on, the vertical counter
 * currently corresponds to a scanline in which text is to be displayed.
 * 
 * If hires graphics IS NOT currently to be displayed, then
 * 
 *     A10 = PAGE1  : 1 if page one is selected, 0 if page two is selected
 *     A11 = PAGE2  : 0 if page one is selected, 1 if page two is selected
 *     A12 = HBL    : 1 if in horizontal blanking time (horizontal counter
 *                    states 0x00,0x40-0x57), 0 if not in horizontal blanking
 *                    time (horizontal counter states 0x58-0x7F)
 *     A13 = 0
 *     A14 = 0
 *     A15 = 0
 * 
 *  If hires graphics IS currently to be displayed, then
 *
 *     A10 = VA     : the least significant bit of the vertical counter
 *     A11 = VB
 *     A12 = VC
 *     A13 = PAGE1  : 1 if page one is selected, 0 if page two is selected
 *     A14 = PAGE2  : 0 if page one is selected, 1 if page two is selected
 *     A15 = 0
 * 
 * The code in mega_ii_cycle implements the horizontal and vertical counters
 * and the formation of the video scan address as described above in a fairly
 * straightforward way. The main complication is how mixed mode is handled.
 * When hires mixed mode is set on the Apple II, the product V2 & V4 deselects
 * hires mode. V2 & V4 is true (1) during vertical counter states 0x1A0-0x1BF
 * and 0x1E0-0x1FF, corresponding to scanlines 160-191 (the text window at
 * the bottom of the screen in mixed mode) and scanlines 224-261 (undisplayed
 * lines in vertical blanking time). This affects how bits A14-A10 of the
 * address is formed.
 * 
 * These bits are formed in the following way: Three variables (data members)
 * called page_bit, lores_mode_mask and hires_mode_mask are established which
 * store the current video settings. If page one is selected, page_bit = 0x2000.
 * If page two is selected, page_bit = 0x4000, which in both cases places a set
 * bit at the correct location for forming the address when displaying hires
 * graphics. If hires graphics is selected, hires_mode_mask = 0x7C00, with the
 * set bits corresponding to A14-A10, and lores_mode_mask = 0x0000. If hires
 * graphics is not selected, hires_mode_mask = 0x0000, and lores_mode_mask =
 * 0x1C00, with the set bits corresponding to A12-A10. Thus, these two variables
 * are masks for the high bits of the address in each mode.
 * 
 * For each cycle, a variable HBL is given the value 0x1000 if the horizontal
 * count < 0x58, and the value 0x0000 if the horizontal count >= 0x58, then
 * values for bits A14-A10 are formed for both the hires and not-hires cases.
 * If there were no mixed mode, the values would be formed like this:
 * 
 *     Hires A15-A10 = (page_bit | (vertical-count << 10)) & hires_mode_mask
 *     Lores A15-A10 = ((page_bit >> 3) | HBL) & lores_mode_mask
 * 
 * Since the variables hires_mode_bits and lores_mode_bits are masks, they
 * ensure that at all times, one of these values is zero, and the other is the
 * correct high bits of the address scanned by the video system.
 * 
 * To implement mixed mode, two more variables are introduced: mixed_lores_mask
 * and mixed_hires_mask. If mixed mode is not selected, or if mixed mode is
 * selected but V2 & V4 == 0, then mixed_lores_mask = 0x0000 and mixed_hires_mask
 * = 0x7C00. If mixed mode is selected and (V2 & V4) == 1, then mixed_lores_mask
 * = 0x1C00 and mixed_hires_mask = 0x0000.
 * 
 * Combined masks for the high bits of both text/lores and hires are then formed
 * 
 *     combined_lores_mask = mixed_lores_mask | lores_mode_mask
 *     combined_hires_mask = mixed_hires_mask & hires_mode_mask
 * 
 * This indicates that a text/lores address will be generated if either
 * text/lores mode is selected (lores_mode_mask != 0) OR if hires mixed mode
 * is selected and the vertical counter specifies a text mode scanline
 * (mixed_lores_mask != 0). A hires address will be generated if hires mode is
 * selected (hires_mode_mask != 0) AND the vertical counter does not specify a
 * text mode scanline (mixed_hires_mask != 0).
 * 
 * The high bits of the address generated by the video scanner for both
 * text/lores and hires mode are then formed
 * 
 *     Hires A15-A10 = (page_bit | (vertical-count << 10)) & combined_hires_mask
 *     Lores A15-A10 = ((page_bit >> 3) | HBL) & combined_lores_mask
 * 
 * The result is that, for each cycle, either Hires A15-A10 is nonzero or
 * Lores A15-A10 is nonzero, depending on the selected graphics mode and the
 * state of the vertical counter.
 *
 * Finally the address to be scanned is formed by summing the individual parts
 * A2-A0, A6-A3, A9-A7, A15-A10.
 */

void apple_ii_video_scanner(cpu_state *cpu)
{
    display_state_t *ds = (display_state_t *)get_module_state(cpu, MODULE_DISPLAY);

    ds->hcount += 1;
    if (ds->hcount == 65) {
        ds->hcount = 0;
        ds->vcount += 1;
        if (ds->vcount == 262)
            ds->vcount = 0;
    }

    uint16_t address = (*(ds->video_addresses))[65*ds->vcount+ds->hcount];

    ds->video_byte = cpu->mmu->read_raw(address);

    ds->video_hbl = (ds->hcount < 25);
    ds->video_vbl = (ds->vcount >= 192);

    if (ds->video_vbl || ds->video_hbl)
        return;

    ds->video_data[ds->video_data_size++] = (uint8_t)ds->video_mode;
    ds->video_data[ds->video_data_size++] = ds->video_byte;
}

void incr_cycles(cpu_state *cpu)
{
    cpu->cycles++;
    cpu->ns_since_bus_cycle += cpu->cycle_duration_ns;
    if (cpu->ns_since_bus_cycle >= clock_mode_info[CLOCK_1_024MHZ].cycle_duration_ns) {
        cpu->ns_since_bus_cycle -= clock_mode_info[CLOCK_1_024MHZ].cycle_duration_ns;
        apple_ii_video_scanner(cpu);
        cpu->bus_cycles++;
    }
};

