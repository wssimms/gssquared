# Mockingboard

Mockingboard is a sound card developed for Apple II computers, and was the best sound generation available on Apple IIs until the release of the Apple IIgs which had waveform synthesizer onboard.

The Mockingboard is built around the AY-3-8910 chip, a sound generation chip.

Wikipedia says:
The AY-3-8910 is a simple finite-state machine.

Its state of sixteen 8-bit registers ..

```
Six registers control the pitches produced in the three primary channels. The frequency to generate is held in two 8-bit registers dedicated to each channel, but the value is limited to 12-bits for other reasons, for a total of 4095 (the register value is used as the frequency divider and 0 is treated as 1) different pitches. Another register controls the period of a pseudo-random noise generator (a total of 31 different cycle times), while another controls the mixing of this noise into the three primary channels.
```

* (6) frequency registers (two 8-bit, limited to 12 bits total). Register value is a frequency divider. (What is the frequency?)
* (3) channel volume (3 more registers, one per channel)
* (1) Pseudo-random noise generator timing (31 cycle times)
* (1) mixing or pseudo-random noise into main channels
* (2??) optional envelope controls
* (3) three registers control times of the envelope controller: envelope type and cycle time.

Envelope types: sawtooth; triangle; starting on min or max. Only one envelope shared among all three channels.

16 total registers.

Some clone cards had multiple of these chips, one had four chips for 12 voices. Most software only supported 2 chips / 6 voices.

Here's if you want to build your own Mockingboard:

https://wiki.reactivemicro.com/images/2/24/Mockingboard_Assembly_Guide_2019.pdf

All registers can be read/written. CPU can read "present state", or "programmed values". 

The "analog sound outputs can each provide 4 bits of logarithmic digital to analog conversion". <- what's this?

However, the aforementioned Mockingboard demo disk (available freely on ReactiveMicroâ€™s Wiki) actually contains this for you. Demo disk available here:

https://wiki.reactivemicro.com/Mockingboard

to wit two Demo disks. This will be good for testing.

http://www.downloads.reactivemicro.com/Apple%20II%20Items/Hardware/Mockingboard_A/Software/mockingboard1.dsk

http://www.downloads.reactivemicro.com/Apple%20II%20Items/Hardware/Mockingboard_A/Software/mockingboard2.dsk

This is a MB-Audit (tester) program:
https://github.com/tomcw/mb-audit

exercises a Mockingboard and tests it.

This will be a fairly involved emulation (maybe), but it will be an extremely satisfying one.

ok so let's think about this stuff and define terms.

First off:

*tone period* - this is controlling the frequency. 

*Envelope* - In sound and music, an envelope describes how a sound changes over time. For example, a piano key, when struck and held, creates a near-immediate initial sound which gradually decreases in volume to zero. An envelope may relate to elements such as amplitude, frequency or pitch. So this is basically the shape of the waveform. Is this what is meant? Above, it says "envelope types include: sawtooth; triangle". 

Here's the data sheet for the AY:
https://map.grauw.nl/resources/sound/generalinstrument_ay-3-8910.pdf

Tone Generators: "produce the basic square wave tone frequencies for each channel (A, B, C)
Mixers: combine the outputs of the tone generators and the noise generator. one for each channel (a,b,c)
amplitude control: provides the D/A converters with either a fixed or variable amplitude pattern. Fixed amplitude is under CPU control; variable amplitude is accomplished by using the Envelope Generator.
Envelope Generator: produces an envelope pattern which can be used to amplitude modulate the output of each Mixer.

### Tone Generator Control - Registers R0, R1, R2, R3, R4, R5

| Operation | Registers | Function |
|-|-|-|
| Tone Generator Control | R0 - R5 | Program tone periods |
| Noise Generator Control | R6 | Program noise period |
| Mixer Control | R7 | Enable tone and/or noise on selected channels |
| Amplitude Control | R10 - R12 | select "fixed" or "envelope variable" amplitudes |
| Envelope Generator Control | R13 - R15 | Program Envelope period and select envelope pattern|

| Coarse Tune Register | Channel | Fine Tune Register |
|-|-|-|
| R1 | A | R0 |
| R3 | B | R2 |
| R5 | C | R4 |

The 4 MSB of the Coarse register is not used; Coarse B3-B0 + Fine B7-R0 are the 12-bit value up to 4095.

"The frequency of each square wave generated by the three Tone Generators" is obtained by counting down the input clock by 16, then by further counting down the result by the programmed 12-bit tone period value. (What's the input clock on a Mockingboard? Reactive Micro parts list to the rescue.. 

Is it the Apple II clock? Divide by 16. then divide by the counter. that would be 65KHz. 

### Noise Generator Control - Register R6

Bits B7 - B5 unused. Bits B4 - B0 (5 bits).
Frequency of the noise source is obtained by first counting down the input clock by 16, then by further counting down the result by the 5 bit noise period value.

### Mixer Control - I/O Enable

There are two "general purpose I/O ports" which I think are likely unused on a Mockingboard.

Bits B5 - B3 are NOT Noise Enable C B A; B2 - B0 are NOT Tone Enable C B A. So you can mix tone and noise on the same channel.

Instead of mixing, instead have a AudioStream for each one of these. (i.e., treat as six channels instead of 3).

### Amplitude Control - R10, R11, R12

R10 - A
R11 - B
R12 - C

B4 is amplitude mode. B3 - B0 is 4-bit fixed amplitude level.

### Envelope Generator Control - R13, R14, R15

R13 and R14 vary the frequency of the envelope. relative shape and cycle pattern is controlled by R15.

#### Envelope Period Control - R13, R14

Frequency of the envelope is obtained by first counting down the input clock by 256, then further counting down the result by the programmed 16-bit envelope period value. R14 is Coarse (Hi) and R13 is Fine (lo).

Envelope Shape - R15

The envelope generator further counts down the envelope frequency by 16, producing a 16-state-per-cycle envelope pattern as defined by its 4 bit counter E3, E2, E1, E0. The shape/cycle control is bits B3 - B0 of R15.
B0 - Hold
B1 - Alternate
B2 - Attack
B3 - Continue

These together create particular waveforms. 

### Output

All of these together create a 4-bit output level; which is logarithmic. i.e., 12 is significantly higher than 11. 

Each envelope is a repeating cycle; for instance, the triangle wave is 16 steps down from 15 to 0, followed by 16 steps up to 0 to 15, repeating. (B1 'alternate' bit is set).

It's all based on 16 samples, either repeating, or non-repeating.

The length of the 16 samples is the EP, Envelope Period.

In any given envelope period, the amplitude:
* changes by 1 step - levels 0 to 15 or levels 15 to 0.
* stays at level 15 or at level 0

Attack = 0 means go from 15 to 0; 1 means go from 0 to 15;
Hold means, whatever the level was at the end of the last EP, keep it at that level.
continue means repeat the previous EP form.
Alternate means repeat the previous EP form in reverse.

in effect, the envelope generator output E3-E0 is a 4-bit counter, which has three states:
step; (attack=1, step up)
step-reverse; (attack=0, step down)
hold.

So with these 4 bits of inputs I should be able to emulate all these waveforms. Ought to be easy..

Handling stuff that manually controls the amplitude is going to require some effort a'la the current speaker.cpp device.

Due to the logarithmic DAC, a triangle wave doesn't sound so harsh. It's a mix of a sine wave and a triangle wave.

In a modern system, we directly control the amplitude on every sample, which is how we generate frequencies.

(Contemplate this logarithmic thing in speaker.cpp?)

All of this supposedly can be generated by state machines. So, definitely gotta know the input frequency. Maybe it's the Apple II 1.0205?

So Step 1 is to create a state machine that based on B3-B0 can create the 16-sample envelope sections.

Or instead of that, how about we just define lookup tables with those. A 2nd lookup table for the logarithmic gizmo.

From AppleWin:

```
	/* AY output doesn't match the claimed levels; these levels are based
	* on the measurements posted to comp.sys.sinclair in Dec 2001 by
	* Matthew Westcott, adjusted as I described in a followup to his post,
	* then scaled to 0..0xffff.
	*/
	static const int levels[16] = {
		0x0000, 0x0385, 0x053D, 0x0770,
		0x0AD7, 0x0FD5, 0x15B0, 0x230C,
		0x2B4C, 0x43C1, 0x5A4B, 0x732F,
		0x9204, 0xAFF1, 0xD921, 0xFFFF
	};
```

So, once you have all this, the maximum number of EPs per second if we do one sample per 44.1KHz is 2,756. But does this combine with the square wave generator in some way?

yeah. so the frequency is not strictly controlled by the 16 sample EP. 

There's a registers / frequency table in the manual. Example: B8, 7902hz. is coarse=0,fine=8. if 8 is number of ticks delay between cycle change, then 8 * 7902 = 63216.

We cannot represent a 64KHz frequency with 44.1KHz sample rate. We -can- with a sample rate of 120,000. Is that possible? what if we do 120K samples of 8 bit unsigned. That would be 120KB/sec, an eminently reasonable speed. And then we're dumping data into there pretty much raw as-is, without having to sample shift it ourselves. We're letting SDL do the mixing and downsampling as needed to hardware. I guess we could test that?

and if this worked, could I do the same for the speaker-click emulator?

NO, we don't need to do any of that. The Envelope as a waveform is multiplied by the base square wave. They are completely independent counters/frequencies.

The "tone" is a square-wave output. The "envelope" controls the amplitude. When you multiply them together (where tone is from 0.0 to 1.0, and envelope is also from 0.0 to 1.0), then you can get a variety of interesting effects.

The "noise generator" will be pre-calculated noise in a LUT. And the envelope can be a LUT also, where we lookup values for TWO cycles and then repeat or not the 2nd of those cycles.

What we do need is a reliable way to generate a square wave at an arbitrary frequency into a 44100Hz sample stream. the highest possible frequency of the chip is crazy, 64KHz. But nobody can hear that. We don't need to represent that. (or do we?).


## R6522 - VIA

This is an I/O controller. Often paired with 6502s and prominent on many apple II cards. This is the interface between the Apple II bus, and AY-3-8910 chip(s).

So the MockingBoardManual.rtf shows routines for programming the MB. First are routines:
INIT, LATCH, WRITE, RESET that send commands to a 6522. Then there is START, which actually sends commands to the AY.

Basically: 
```
   LDY #$REGISTER
   STY ORA              ($C401)
   JSR LATCH            ('latch' in the register number)
   LDA #$DATA
   STA ORA
   JSR WRITE            write the data to the AY

LATCH:
    LDA #$07
    STA ORB
    LDA #$04
    STA ORB

WRITE:
    LDA #$06
    STA ORB
    LDA #$04
    STA ORB

; these set the 6522 port directions
INIT:
    LDA #$FF            set port a for output
    STA DDRA            set data direction
    LDA #$07            set port b for output
    STA DDRB            
```

AppleWin implements the whole 6522 and then separately 'attaches' it to the AY in its code. I will implement a simpler approach since we only need to support normal use cases. But at a minimum, we should emulate the DDR (direction registers) as they might also mask data being read/written.

In the case above, DDRB is set to 7 because port B is the 'Command' port, and commands are only 0-7. These may be wired directly to the AY somehow.. yes, PB2-PB0 are wired:

* PB2 - /RESET
* PB1 - BDIR - direction of data
* PB0 - BC1

Thus, the RESET routine is: clear that bit (/RESET means do a reset) then turn reset off (/RESET = 1 is disabled).

to send a command, you LATCH the command then WRITE the data, i.e.
```
cmd -> ORA
7, then 4 -> ORB
data -> ORA
6, then 4 -> ORB
```

That's pretty straightforward, if poorly documented.

6522 data sheet:
https://www.princeton.edu/~mae412/HANDOUTS/Datasheets/6522.pdf

lots more information on the timer counters and interrupt scheme.


## Interrupts

There is some use of interrupts. However, in the example code, it appears to be only for Speech. It uses the 6522 interrupt handling stuff. Interrupt flag is $C40D, Interrupt Enable is $C40C.

In the speech driver, it is using interrupts to feed data from a "data file" as needed. (Because each phoneme takes a certain amount of time to output?)

I would not assume that nothing else uses the interrupt logic however.

This brings up the general lack of IRQ support in the EMU right now. for IRQ support, I guess we would have an IRQ_asserted flag for each slot, in the cpu struct. Then we can just check if that is non-zero to determine IRQ assert input into the CPU loop.

## SSI 263A Phoneme Speech Synthesizer

Some Mockingboards also had a speech synthesis chip. (See the doc above).

## ROM

Mockingboard.D ROM is at:

https://github.com/AppleWin/AppleWin/blob/master/resource/Mockingboard-D.rom

But whoops, that's the Apple IIc standalone thing.

## Compatibility

see spreadsheet

Ultima IV - I am getting fairly far into it; mockingboard music works in the intro (interrupt driven); but at various points in the game I get hung up at PC 0x0348. Why? Don't Know. Need a debugger! the code seems to be:

0348: LDA $82
034A: BNE $0348

that is clearly something pending interrupts. Well, of course I haven't finished all the code yet. Maybe they use timer 2? run with full MB debug.

Bank Street Music Writer - it pings early on:
mb_read_Cx00: 04
mb_read_Cx00: 04

That's the T1 low-order counter. In almost all cards, this will be ROM and the value won't change. I bet they're checking to see if it changes.

